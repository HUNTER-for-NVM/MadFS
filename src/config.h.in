#pragma once

// see https://cmake.org/cmake/help/latest/command/configure_file.html
#cmakedefine01 ULAYFS_MEM_PROTECT
#cmakedefine01 ULAYFS_NO_SHARING
#cmakedefine01 ULAYFS_RELAXED
#cmakedefine01 ULAYFS_USE_HUGE_PAGE
#cmakedefine01 ULAYFS_USE_MAP_SYNC
#cmakedefine01 ULAYFS_FORCE_MAP_POPULATE
#cmakedefine01 ULAYFS_TX_FLUSH_ONLY_FSYNC
#cmakedefine01 ULAYFS_USE_PMEMCHECK

#cmakedefine GIT_BRANCH "@GIT_BRANCH@"
#cmakedefine GIT_COMMIT_HASH "@GIT_COMMIT_HASH@"
#cmakedefine CMAKE_BUILD_TYPE "@CMAKE_BUILD_TYPE@"

#include <ostream>

namespace ulayfs {

constexpr static struct BuildOptions {
  constexpr static const char* build_type = CMAKE_BUILD_TYPE;
  constexpr static const char* git_branch = GIT_BRANCH;
  constexpr static const char* git_commit_hash = GIT_COMMIT_HASH;

  constexpr static bool mem_protect = ULAYFS_MEM_PROTECT;
  constexpr static bool no_sharing = ULAYFS_NO_SHARING;
  constexpr static bool relaxed = ULAYFS_NO_SHARING || ULAYFS_RELAXED;
  constexpr static bool use_huge_page = ULAYFS_USE_HUGE_PAGE;
  constexpr static bool use_map_sync = ULAYFS_USE_MAP_SYNC;
  constexpr static bool force_map_populate = ULAYFS_FORCE_MAP_POPULATE;
  constexpr static bool tx_flush_only_fsync = ULAYFS_TX_FLUSH_ONLY_FSYNC;
  constexpr static bool use_pmemcheck = ULAYFS_USE_PMEMCHECK;

#ifdef NDEBUG
  constexpr static bool debug = false;
#else
  constexpr static bool debug = true;
#endif

#ifdef __CLWB__
  constexpr static bool support_clwb = true;
#else
  constexpr static bool support_clwb = false;
#endif

#ifdef __CLFLUSHOPT__
  constexpr static bool support_clflushopt = true;
#else
  constexpr static bool support_clflushopt = false;
#endif

  friend std::ostream& operator<<(std::ostream& out, const BuildOptions& _) {
    out << "BuildOptions: \n";
    out << "\tbuild_type: " << build_type << "\n";
    out << "\tgit_branch: " << git_branch << "\n";
    out << "\tgit_commit_hash: " << git_commit_hash << "\n";
    out << "\tdebug: " << debug << "\n";
    out << "\tuse_pmemcheck: " << use_pmemcheck << "\n";
    out << "\tmem_protect: " << mem_protect << "\n";
    out << "\tno_sharing: " << no_sharing << "\n";
    out << "\trelaxed: " << relaxed << "\n";
    out << "\tuse_huge_page: " << use_huge_page << "\n";
    out << "\tuse_map_sync: " << use_map_sync << "\n";
    out << "\tforce_map_populate: " << force_map_populate << "\n";
    out << "\ttx_flush_only_fsync: " << tx_flush_only_fsync << "\n";
    out << "\tsupport_clwb: " << support_clwb << "\n";
    out << "\tsupport_clflushopt: " << support_clflushopt << "\n";
    return out;
  }
} build_options;

static struct RuntimeOptions {
  bool show_config{true};
  const char* log_file{};
  int log_level{0};

  RuntimeOptions() noexcept {
    if (std::getenv("ULAYFS_NO_SHOW_CONFIG")) show_config = false;
    log_file = std::getenv("ULAYFS_LOG_FILE");
    if (auto str = std::getenv("ULAYFS_LOG_LEVEL"); str)
      log_level = std::atoi(str);
  };

  friend std::ostream& operator<<(std::ostream& out,
                                  const RuntimeOptions& opt) {
    out << "RuntimeOptions: \n";
    out << "\tshow_config: " << opt.show_config << "\n";
    out << "\tlog_file: " << (opt.log_file ? opt.log_file : "None") << "\n";
    out << "\tlog_level: " << opt.log_level << "\n";
    return out;
  }
} runtime_options;

}  // namespace ulayfs
