#!/usr/bin/env python3

import argparse
import logging
import pprint
from pathlib import Path

from scripts.utils import system, check_any_args_passed, get_timestamp

logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger("run")


class Runner:
    def __init__(self, cmake_target, build_type=None, output_path=None, **kwargs):
        self.is_leveldb = cmake_target.startswith("leveldb")
        self.is_micro = cmake_target == "micro"
        self.is_bench = self.is_micro or self.is_leveldb

        if build_type is None:
            build_type = "release" if self.is_bench else "debug"
        if output_path is None:
            output_path = Path("results") / cmake_target / build_type / get_timestamp()

        self.build_type = build_type
        self.build_path = Path(f"build-{build_type}")
        self.cmake_target = cmake_target
        self.output_path = output_path
        self.exe_path = None

        self.output_path.mkdir(parents=True, exist_ok=True)

    def build(self, cmake_args="", link_ulayfs=True, **kwargs):
        if self.is_bench:
            cmake_args += " -DULAYFS_BUILD_BENCH=ON "

        config_log_path = self.output_path / "config.log"
        build_log_path = self.output_path / "build.log"

        cmake_args += f" -DULAYFS_LINK_LIBRARY={'ON' if link_ulayfs else 'OFF'} "

        # build
        system(
            f"make {self.build_type} "
            f"CMAKE_ARGS='{cmake_args}' "
            f"BUILD_TARGETS='{self.cmake_target}' ",
            log_path=build_log_path,
        )

        # save config
        with open(config_log_path, "w") as fout:
            pprint.pprint(locals(), stream=fout)
        system(f"cmake -L -N {self.build_path} >> {config_log_path}")
        ulayfs_path = self.build_path / "libulayfs.so"
        if self.is_leveldb:
            self.exe_path = self.build_path / "_deps" / "leveldb-build" / self.cmake_target
        else:
            self.exe_path = self.build_path / self.cmake_target

    def run(self, prog_args="", **kwargs):
        assert self.exe_path is not None

        if self.is_micro:
            prog_args += " --benchmark_counters_tabular=true "

        cmd = f"{self.exe_path} {prog_args}"
        run_log_path = self.output_path / "run.log"

        # execute
        if self.build_type == "pmemcheck":
            pmemcheck_dir = self.build_path / "_deps" / "pmemcheck-src"
            system(
                f"VALGRIND_LIB={pmemcheck_dir}/libexec/valgrind/ "
                f"{pmemcheck_dir}/bin/valgrind --tool=pmemcheck --trace-children=yes "
                f"{cmd}",
                log_path=run_log_path,
            )

        elif self.build_type == "profile":
            perf_data = self.output_path / "perf.data"
            flamegraph_output = self.output_path / "flamegraph.svg"
            flamegraph_dir = self.build_path / "_deps" / "flamegraph-src"

            # record perf data
            system(
                f"perf record --freq=997 --call-graph dwarf -o {perf_data} {cmd}",
                log_path=run_log_path,
            )

            # show perf results in terminal
            system(f"perf report -i {perf_data}")

            # generate flamegraph
            system(
                f"perf script -i {perf_data} | "
                f"{flamegraph_dir}/stackcollapse-perf.pl | "
                f"{flamegraph_dir}/flamegraph.pl > {flamegraph_output}"
            )
            logger.info(f"The flamegraph is available at `{flamegraph_output}`")

        else:
            system(cmd, log_path=run_log_path)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Build and run tests or benchmarks")
    parser.add_argument(
        "cmake_target",
        help="see .cpp files in `test` and `bench` for available targets",
    )
    parser.add_argument(
        "build_type",
        nargs=argparse.OPTIONAL,
        help="see Makefile for available build types",
    )
    parser.add_argument(
        "-c",
        "--cmake_args",
        default="",
        help="additional build arguments to be passed to CMake",
    )
    parser.add_argument(
        "-p",
        "--prog_args",
        default="",
        help="arguments to be passed to the program during execution",
    )
    parser.add_argument(
        "-d",
        "--disable_ulayfs",
        action="store_false",
        dest="link_ulayfs",
        help="do not link the ulayfs library",
    )
    parser.add_argument(
        "-o",
        "--output_path",
        type=Path,
        help="specify the output directory",
    )
    check_any_args_passed(parser)
    args = parser.parse_args()
    logger.debug(f"args={args}")

    runner = Runner(**vars(args))
    runner.build(**vars(args))
    runner.run(**vars(args))
