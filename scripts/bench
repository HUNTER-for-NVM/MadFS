#!/usr/bin/env python3
import argparse
import logging
from pathlib import Path

from fs import fs_paths
from runner import Runner
from utils import root_dir, get_timestamp, add_common_args, system, drop_cache, init

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("bench")


class Benchmark:
    def __init__(self, build_type, additional_args, fs_names, **kwargs):
        init(configure=True)

        self.build_type = build_type
        self.additional_args = additional_args
        self.fs_names = fs_names
        self.cmake_target = self.get_cmake_target(**kwargs)
        self.result_dir = root_dir / "results" / f"bench_{self.cmake_target}" / get_timestamp()

    def get_cmake_target(self, **kwargs):
        raise NotImplementedError()

    def run_single_config(self, **kwargs):
        raise NotImplementedError()

    def run(self, **kwargs):
        for fs in self.fs_names:
            runner = Runner(self.cmake_target, result_dir=self.result_dir / fs, build_type=self.build_type)
            runner.build()
            self.run_single_config(fs=fs, runner=runner, **kwargs)
        return self.result_dir


class MicroBenchmark(Benchmark):
    def get_cmake_target(self, benchmark, **kwargs):
        return f"micro_{benchmark}"

    def run_single_config(self, fs, runner):
        runner.run(fs=fs, additional_args=self.additional_args)


class YcsbBenchmark(Benchmark):
    def __init__(self, workloads, **kwargs):
        super().__init__(**kwargs)
        self.workloads = workloads

    def get_cmake_target(self, **kwargs):
        return "leveldb_ycsb"

    def run_single_config(self, fs, runner):
        dbdir = fs_paths[fs] / "bench-dbdir"
        for w in self.workloads:
            system(f"rm -rf {dbdir} && mkdir -p {dbdir}")
            for load in [True, False]:
                drop_cache()
                trace_name = f"{w}-{'load' if load else 'run'}"
                trace_path = root_dir / "bench" / "ycsb-traces-large" / f"{trace_name}.txt"
                cmd = f"{runner.prog_path} -f {trace_path} -d {dbdir}"
                runner.run(cmd=cmd, fs=fs, prog_log_name=f"{trace_name}.log", additional_args=self.additional_args)
            system(f"rm -rf {dbdir}")


def main(benchmark, result_dir, **kwargs):
    from plot import plot_micro_st, plot_micro_mt, plot_micro_meta, plot_ycsb

    if result_dir is None:
        bm_classes = {
            "st": MicroBenchmark,
            "mt": MicroBenchmark,
            "meta": MicroBenchmark,
            "ycsb": YcsbBenchmark,
        }
        result_dir = bm_classes[benchmark](benchmark=benchmark, **kwargs).run()

    plot_fns = {
        "st": plot_micro_st,
        "mt": plot_micro_mt,
        "meta": plot_micro_meta,
        "ycsb": plot_ycsb,
    }
    plot_fns[benchmark](result_dir)

    logger.info(f"Results saved to {result_dir}")


if __name__ == "__main__":
    argparser = argparse.ArgumentParser()
    subparsers = argparser.add_subparsers(dest="benchmark", required=True)
    for bm in ["st", "mt", "meta", "ycsb"]:
        subparser = subparsers.add_parser(bm)
        add_common_args(subparser)
        subparser.add_argument(
            "-f",
            "--fs_names",
            default=fs_paths.keys(),
            choices=fs_paths.keys(),
            nargs="+",
            help="Filesystems to benchmark",
        )
        subparser.add_argument(
            "-p",
            "--result_dir",
            type=Path,
            help="If set, plot the results in the given directory w/o running the benchmark",
        )
        if bm == "ycsb":
            all_workloads = ("a", "b", "c", "d", "e", "f")
            subparser.add_argument(
                "-w",
                "--workloads",
                type=str,
                nargs="+",
                default=all_workloads,
                choices=all_workloads,
            )

    args = argparser.parse_args()
    if args.build_type is None:
        args.build_type = "release"
    logger.info(f"args={args}")
    main(**vars(args))
